/* soapStub.h
   Generated by gSOAP 2.7.14 from josso-1.2.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#include "JOSSOIsapiAgent/agent/wsclient/gsoap/stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns3__ResolveAuthenticationAssertionRequestType
#define SOAP_TYPE_ns3__ResolveAuthenticationAssertionRequestType (8)
/* ns3:ResolveAuthenticationAssertionRequestType */
class SOAP_CMAC ns3__ResolveAuthenticationAssertionRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string assertionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns3__ResolveAuthenticationAssertionRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ResolveAuthenticationAssertionRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ResolveAuthenticationAssertionRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ResolveAuthenticationAssertionResponseType
#define SOAP_TYPE_ns3__ResolveAuthenticationAssertionResponseType (9)
/* ns3:ResolveAuthenticationAssertionResponseType */
class SOAP_CMAC ns3__ResolveAuthenticationAssertionResponseType
{
public:
	std::string ssoSessionId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	std::string securityDomain;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns3__ResolveAuthenticationAssertionResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ResolveAuthenticationAssertionResponseType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__ResolveAuthenticationAssertionResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AssertIdentityWithSimpleAuthenticationRequestType
#define SOAP_TYPE_ns3__AssertIdentityWithSimpleAuthenticationRequestType (10)
/* ns3:AssertIdentityWithSimpleAuthenticationRequestType */
class SOAP_CMAC ns3__AssertIdentityWithSimpleAuthenticationRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string securityDomain;	/* required element of type xsd:string */
	std::string username;	/* required element of type xsd:string */
	std::string password;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns3__AssertIdentityWithSimpleAuthenticationRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AssertIdentityWithSimpleAuthenticationRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__AssertIdentityWithSimpleAuthenticationRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AssertIdentityWithSimpleAuthenticationResponseType
#define SOAP_TYPE_ns3__AssertIdentityWithSimpleAuthenticationResponseType (11)
/* ns3:AssertIdentityWithSimpleAuthenticationResponseType */
class SOAP_CMAC ns3__AssertIdentityWithSimpleAuthenticationResponseType
{
public:
	std::string assertionId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns3__AssertIdentityWithSimpleAuthenticationResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AssertIdentityWithSimpleAuthenticationResponseType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__AssertIdentityWithSimpleAuthenticationResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GlobalSignoffRequestType
#define SOAP_TYPE_ns3__GlobalSignoffRequestType (12)
/* ns3:GlobalSignoffRequestType */
class SOAP_CMAC ns3__GlobalSignoffRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string ssoSessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns3__GlobalSignoffRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GlobalSignoffRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__GlobalSignoffRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GlobalSignoffResponseType
#define SOAP_TYPE_ns3__GlobalSignoffResponseType (13)
/* ns3:GlobalSignoffResponseType */
class SOAP_CMAC ns3__GlobalSignoffResponseType
{
public:
	std::string ssoSessionId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns3__GlobalSignoffResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GlobalSignoffResponseType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__GlobalSignoffResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSOIdentityProviderErrorType
#define SOAP_TYPE_ns3__SSOIdentityProviderErrorType (14)
/* ns3:SSOIdentityProviderErrorType */
class SOAP_CMAC ns3__SSOIdentityProviderErrorType
{
public:
	std::string errMessage;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns3__SSOIdentityProviderErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSOIdentityProviderErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSOIdentityProviderErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AssertionNotValidErrorType
#define SOAP_TYPE_ns3__AssertionNotValidErrorType (15)
/* ns3:AssertionNotValidErrorType */
class SOAP_CMAC ns3__AssertionNotValidErrorType
{
public:
	std::string assertionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns3__AssertionNotValidErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AssertionNotValidErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__AssertionNotValidErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FindUserInSessionRequestType
#define SOAP_TYPE_ns3__FindUserInSessionRequestType (16)
/* ns3:FindUserInSessionRequestType */
class SOAP_CMAC ns3__FindUserInSessionRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string ssoSessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns3__FindUserInSessionRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FindUserInSessionRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__FindUserInSessionRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FindUserInSessionResponseType
#define SOAP_TYPE_ns3__FindUserInSessionResponseType (17)
/* ns3:FindUserInSessionResponseType */
class SOAP_CMAC ns3__FindUserInSessionResponseType
{
public:
	class ns3__SSOUserType *ns3__SSOUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:SSOUserType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns3__FindUserInSessionResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FindUserInSessionResponseType() : ns3__SSOUser(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__FindUserInSessionResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FindUserInSecurityDomainRequestType
#define SOAP_TYPE_ns3__FindUserInSecurityDomainRequestType (18)
/* ns3:FindUserInSecurityDomainRequestType */
class SOAP_CMAC ns3__FindUserInSecurityDomainRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string securityDomain;	/* required element of type xsd:string */
	std::string username;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns3__FindUserInSecurityDomainRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FindUserInSecurityDomainRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__FindUserInSecurityDomainRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FindUserInSecurityDomainResponseType
#define SOAP_TYPE_ns3__FindUserInSecurityDomainResponseType (19)
/* ns3:FindUserInSecurityDomainResponseType */
class SOAP_CMAC ns3__FindUserInSecurityDomainResponseType
{
public:
	ns3__SSOUserType *ns3__SSOUser;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:SSOUserType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns3__FindUserInSecurityDomainResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FindUserInSecurityDomainResponseType() : ns3__SSOUser(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__FindUserInSecurityDomainResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FindRolesBySSOSessionIdRequestType
#define SOAP_TYPE_ns3__FindRolesBySSOSessionIdRequestType (20)
/* ns3:FindRolesBySSOSessionIdRequestType */
class SOAP_CMAC ns3__FindRolesBySSOSessionIdRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string ssoSessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns3__FindRolesBySSOSessionIdRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FindRolesBySSOSessionIdRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__FindRolesBySSOSessionIdRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FindRolesBySSOSessionIdResponseType
#define SOAP_TYPE_ns3__FindRolesBySSOSessionIdResponseType (21)
/* ns3:FindRolesBySSOSessionIdResponseType */
class SOAP_CMAC ns3__FindRolesBySSOSessionIdResponseType
{
public:
	std::string *username;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	std::vector<class ns3__SSORoleType * >roles;	/* optional element of type ns3:SSORoleType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns3__FindRolesBySSOSessionIdResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FindRolesBySSOSessionIdResponseType() : username(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__FindRolesBySSOSessionIdResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UserExistsRequestType
#define SOAP_TYPE_ns3__UserExistsRequestType (22)
/* ns3:UserExistsRequestType */
class SOAP_CMAC ns3__UserExistsRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string securityDomain;	/* required element of type xsd:string */
	std::string username;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns3__UserExistsRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UserExistsRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__UserExistsRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UserExistsResponseType
#define SOAP_TYPE_ns3__UserExistsResponseType (23)
/* ns3:UserExistsResponseType */
class SOAP_CMAC ns3__UserExistsResponseType
{
public:
	bool userexists;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns3__UserExistsResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UserExistsResponseType() : userexists((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__UserExistsResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSOIdentityManagerErrorType
#define SOAP_TYPE_ns3__SSOIdentityManagerErrorType (24)
/* ns3:SSOIdentityManagerErrorType */
class SOAP_CMAC ns3__SSOIdentityManagerErrorType
{
public:
	std::string errMessage;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns3__SSOIdentityManagerErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSOIdentityManagerErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSOIdentityManagerErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__NoSuchUserErrorType
#define SOAP_TYPE_ns3__NoSuchUserErrorType (25)
/* ns3:NoSuchUserErrorType */
class SOAP_CMAC ns3__NoSuchUserErrorType
{
public:
	std::string securityDomain;	/* required element of type xsd:string */
	std::string username;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns3__NoSuchUserErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__NoSuchUserErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__NoSuchUserErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__InvalidSessionErrorType
#define SOAP_TYPE_ns3__InvalidSessionErrorType (26)
/* ns3:InvalidSessionErrorType */
class SOAP_CMAC ns3__InvalidSessionErrorType
{
public:
	std::string sessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns3__InvalidSessionErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__InvalidSessionErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__InvalidSessionErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AccessSessionRequestType
#define SOAP_TYPE_ns3__AccessSessionRequestType (27)
/* ns3:AccessSessionRequestType */
class SOAP_CMAC ns3__AccessSessionRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string ssoSessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns3__AccessSessionRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AccessSessionRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__AccessSessionRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AccessSessionResponseType
#define SOAP_TYPE_ns3__AccessSessionResponseType (28)
/* ns3:AccessSessionResponseType */
class SOAP_CMAC ns3__AccessSessionResponseType
{
public:
	std::string ssoSessionId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns3__AccessSessionResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AccessSessionResponseType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__AccessSessionResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SessionRequestType
#define SOAP_TYPE_ns3__SessionRequestType (29)
/* ns3:SessionRequestType */
class SOAP_CMAC ns3__SessionRequestType
{
public:
	std::string requester;	/* required element of type xsd:string */
	std::string sessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns3__SessionRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SessionRequestType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SessionRequestType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SessionResponseType
#define SOAP_TYPE_ns3__SessionResponseType (30)
/* ns3:SessionResponseType */
class SOAP_CMAC ns3__SessionResponseType
{
public:
	class ns3__SSOSessionType *ns3__SSOSession;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns3:SSOSessionType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns3__SessionResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SessionResponseType() : ns3__SSOSession(NULL), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SessionResponseType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSOSessionErrorType
#define SOAP_TYPE_ns3__SSOSessionErrorType (31)
/* ns3:SSOSessionErrorType */
class SOAP_CMAC ns3__SSOSessionErrorType
{
public:
	std::string errMessage;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns3__SSOSessionErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSOSessionErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSOSessionErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__NoSuchSessionErrorType
#define SOAP_TYPE_ns3__NoSuchSessionErrorType (32)
/* ns3:NoSuchSessionErrorType */
class SOAP_CMAC ns3__NoSuchSessionErrorType
{
public:
	std::string sessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns3__NoSuchSessionErrorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__NoSuchSessionErrorType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__NoSuchSessionErrorType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSOSessionType
#define SOAP_TYPE_ns3__SSOSessionType (33)
/* ns3:SSOSessionType */
class SOAP_CMAC ns3__SSOSessionType
{
public:
	std::string id;	/* required element of type xsd:string */
	LONG64 creationTime;	/* required element of type xsd:long */
	LONG64 lastAccessTime;	/* required element of type xsd:long */
	int maxInactiveInterval;	/* required element of type xsd:int */
	std::string username;	/* required element of type xsd:string */
	LONG64 accessCount;	/* required element of type xsd:long */
	bool valid;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns3__SSOSessionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSOSessionType() : creationTime(0), lastAccessTime(0), maxInactiveInterval(0), accessCount(0), valid((bool)0), soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSOSessionType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSOUserType
#define SOAP_TYPE_ns3__SSOUserType (34)
/* ns3:SSOUserType */
class SOAP_CMAC ns3__SSOUserType
{
public:
	std::vector<class ns3__SSONameValuePairType * >properties;	/* optional element of type ns3:SSONameValuePairType */
	std::string name;	/* required element of type xsd:string */
	std::string securitydomain;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns3__SSOUserType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSOUserType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSOUserType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSORoleType
#define SOAP_TYPE_ns3__SSORoleType (35)
/* ns3:SSORoleType */
class SOAP_CMAC ns3__SSORoleType
{
public:
	std::string name;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns3__SSORoleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSORoleType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSORoleType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SSONameValuePairType
#define SOAP_TYPE_ns3__SSONameValuePairType (36)
/* ns3:SSONameValuePairType */
class SOAP_CMAC ns3__SSONameValuePairType
{
public:
	std::string name;	/* required attribute */
	std::string value;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns3__SSONameValuePairType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SSONameValuePairType() : soap(NULL) { this->soap_default(NULL); }
	virtual ~ns3__SSONameValuePairType() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns3__AssertionNotValidErrorType *ns3__AssertionNotValidError;	/* optional element of type ns3:AssertionNotValidErrorType */
	ns3__SSOIdentityProviderErrorType *ns3__SSOIdentityProviderError;	/* optional element of type ns3:SSOIdentityProviderErrorType */
	ns3__InvalidSessionErrorType *ns3__InvalidSessionError;	/* optional element of type ns3:InvalidSessionErrorType */
	ns3__NoSuchUserErrorType *ns3__NoSuchUserError;	/* optional element of type ns3:NoSuchUserErrorType */
	ns3__SSOIdentityManagerErrorType *ns3__SSOIdentityManagerError;	/* optional element of type ns3:SSOIdentityManagerErrorType */
	ns3__NoSuchSessionErrorType *ns3__NoSuchSessionError;	/* optional element of type ns3:NoSuchSessionErrorType */
	ns3__SSOSessionErrorType *ns3__SSOSessionError;	/* optional element of type ns3:SSOSessionErrorType */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns4__resolveAuthenticationAssertion
#define SOAP_TYPE___ns4__resolveAuthenticationAssertion (61)
/* Operation wrapper: */
struct __ns4__resolveAuthenticationAssertion
{
public:
	ns3__ResolveAuthenticationAssertionRequestType *ns3__ResolveAuthenticationAssertionRequest;	/* optional element of type ns3:ResolveAuthenticationAssertionRequestType */
};
#endif

#ifndef SOAP_TYPE___ns4__assertIdentityWithSimpleAuthentication
#define SOAP_TYPE___ns4__assertIdentityWithSimpleAuthentication (65)
/* Operation wrapper: */
struct __ns4__assertIdentityWithSimpleAuthentication
{
public:
	ns3__AssertIdentityWithSimpleAuthenticationRequestType *ns3__AssertIdentityWithSimpleAuthenticationRequest;	/* optional element of type ns3:AssertIdentityWithSimpleAuthenticationRequestType */
};
#endif

#ifndef SOAP_TYPE___ns4__globalSignoff
#define SOAP_TYPE___ns4__globalSignoff (69)
/* Operation wrapper: */
struct __ns4__globalSignoff
{
public:
	ns3__GlobalSignoffRequestType *ns3__GlobalSignoffRequest;	/* optional element of type ns3:GlobalSignoffRequestType */
};
#endif

#ifndef SOAP_TYPE___ns5__findUserInSession
#define SOAP_TYPE___ns5__findUserInSession (73)
/* Operation wrapper: */
struct __ns5__findUserInSession
{
public:
	ns3__FindUserInSessionRequestType *ns3__FindUserInSessionRequest;	/* optional element of type ns3:FindUserInSessionRequestType */
};
#endif

#ifndef SOAP_TYPE___ns5__findUserInSecurityDomain
#define SOAP_TYPE___ns5__findUserInSecurityDomain (77)
/* Operation wrapper: */
struct __ns5__findUserInSecurityDomain
{
public:
	ns3__FindUserInSecurityDomainRequestType *ns3__FindUserInSecurityDomainRequest;	/* optional element of type ns3:FindUserInSecurityDomainRequestType */
};
#endif

#ifndef SOAP_TYPE___ns5__findRolesBySSOSessionId
#define SOAP_TYPE___ns5__findRolesBySSOSessionId (81)
/* Operation wrapper: */
struct __ns5__findRolesBySSOSessionId
{
public:
	ns3__FindRolesBySSOSessionIdRequestType *ns3__FindRolesBySSOSessionIdRequest;	/* optional element of type ns3:FindRolesBySSOSessionIdRequestType */
};
#endif

#ifndef SOAP_TYPE___ns5__userExists
#define SOAP_TYPE___ns5__userExists (85)
/* Operation wrapper: */
struct __ns5__userExists
{
public:
	ns3__UserExistsRequestType *ns3__UserExistsRequest;	/* optional element of type ns3:UserExistsRequestType */
};
#endif

#ifndef SOAP_TYPE___ns6__accessSession
#define SOAP_TYPE___ns6__accessSession (89)
/* Operation wrapper: */
struct __ns6__accessSession
{
public:
	ns3__AccessSessionRequestType *ns3__AccessSessionRequest;	/* optional element of type ns3:AccessSessionRequestType */
};
#endif

#ifndef SOAP_TYPE___ns6__getSession
#define SOAP_TYPE___ns6__getSession (93)
/* Operation wrapper: */
struct __ns6__getSession
{
public:
	ns3__SessionRequestType *ns3__SessionRequest;	/* optional element of type ns3:SessionRequestType */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (94)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (95)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (97)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (98)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
